/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f411xx_hal.h"
#include "GPIOxDriver.h"

//	Definimos los bits que corresponderÃ¡n a los leds


unsigned char counter_i = 1;

// 	Definimos el handler para el PIN que deseamos configurar

GPIO_Handler_t handlerUserLedPin0 	= {0};
GPIO_Handler_t handlerUserLedPin1 	= {0};
GPIO_Handler_t handlerUserLedPin2 	= {0};
GPIO_Handler_t handlerUserLedPin3 	= {0};
GPIO_Handler_t handlerUserLedPin4 	= {0};
GPIO_Handler_t handlerUserLedPin5 	= {0};
GPIO_Handler_t handlerUserLedPin6	= {0};
GPIO_Handler_t handlerUserButton	= {0};

void EncenderLed(uint8_t counter_i);
void hardware_init(void);
void delay(void);
void show_Binary_Number(unsigned char number);

int main(void){

	//Configuracion inicial del hardware
	hardware_init();

//Este es el ciclo principal, donde se ejecuta todo el programa
	while(1){
		//Cuando NO esta presionado el boton -> entrega el valor 1
		if(GPIO_ReadPin(&handlerUserButton) == 0){
			//Debe disminuir el valor del contador
			GPIO_WritePin(&handlerUserLedPin6, SET);
			counter_i--;

			//Verifica que nunca sea menor...
			if(counter_i < 1){
				counter_i = 60;
			}
			//endendemos el led indicador de subida o bajada

		}
		else{
			//Debe aumentar el valor del contador
			GPIO_WritePin(&handlerUserLedPin6, RESET);
			counter_i++;
			if(counter_i > 60){
				counter_i = 1;
			}

		}

		show_Binary_Number(counter_i);
		delay(); //hacemos un delay de 1 s



	}
}


/*  Inicializacion de todo el hardware */
void hardware_init(void){
	//	GPIOC 9						PC9->Bit_6
		handlerUserLedPin6.pGPIOx 								= GPIOC;
		handlerUserLedPin6.GPIO_PinConfig.GPIO_PinNumber		= PIN_9;
		handlerUserLedPin6.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
		handlerUserLedPin6.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
		handlerUserLedPin6.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
		handlerUserLedPin6.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;
		handlerUserLedPin6.GPIO_PinConfig.GPIO_PinAltFunMode	= AF0;
	//	GPIOC 6						PC6->Bit_5
		handlerUserLedPin5.pGPIOx 								= GPIOC;
		handlerUserLedPin5.GPIO_PinConfig.GPIO_PinNumber		= PIN_6;
		handlerUserLedPin5.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
		handlerUserLedPin5.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
		handlerUserLedPin5.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
		handlerUserLedPin5.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;
		handlerUserLedPin5.GPIO_PinConfig.GPIO_PinAltFunMode	= AF0;
	//	GPIOB 8						PB8->Bit_4
		handlerUserLedPin4.pGPIOx 								= GPIOB;
		handlerUserLedPin4.GPIO_PinConfig.GPIO_PinNumber		= PIN_8;
		handlerUserLedPin4.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
		handlerUserLedPin4.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
		handlerUserLedPin4.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
		handlerUserLedPin4.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;
		handlerUserLedPin4.GPIO_PinConfig.GPIO_PinAltFunMode	= AF0;
	//	GPIOA 6						PA6->Bit_3
		handlerUserLedPin3.pGPIOx 								= GPIOA;
		handlerUserLedPin3.GPIO_PinConfig.GPIO_PinNumber		= PIN_6;
		handlerUserLedPin3.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
		handlerUserLedPin3.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
		handlerUserLedPin3.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
		handlerUserLedPin3.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;
		handlerUserLedPin3.GPIO_PinConfig.GPIO_PinAltFunMode	= AF0;
	//	GPIOC 7						PC7->Bit_2
		handlerUserLedPin2.pGPIOx 								= GPIOC;
		handlerUserLedPin2.GPIO_PinConfig.GPIO_PinNumber		= PIN_7;
		handlerUserLedPin2.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
		handlerUserLedPin2.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
		handlerUserLedPin2.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
		handlerUserLedPin2.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;
		handlerUserLedPin2.GPIO_PinConfig.GPIO_PinAltFunMode	= AF0;
	//	GPIOA	8						PC8->Bit_1
		handlerUserLedPin1.pGPIOx 								= GPIOC;
		handlerUserLedPin1.GPIO_PinConfig.GPIO_PinNumber		= PIN_8;
		handlerUserLedPin1.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
		handlerUserLedPin1.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
		handlerUserLedPin1.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
		handlerUserLedPin1.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;
		handlerUserLedPin1.GPIO_PinConfig.GPIO_PinAltFunMode	= AF0;
	//	GPIOA 7						PA7->Bit_0
		handlerUserLedPin0.pGPIOx 								= GPIOA;
		handlerUserLedPin0.GPIO_PinConfig.GPIO_PinNumber		= PIN_7;
		handlerUserLedPin0.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
		handlerUserLedPin0.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
		handlerUserLedPin0.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
		handlerUserLedPin0.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;
		handlerUserLedPin0.GPIO_PinConfig.GPIO_PinAltFunMode	= AF0;
	//	BOTON
		handlerUserButton.pGPIOx 								= GPIOC;
		handlerUserButton.GPIO_PinConfig.GPIO_PinNumber			= PIN_13;
		handlerUserButton.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_IN;
		handlerUserButton.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
		handlerUserButton.GPIO_PinConfig.GPIO_PinAltFunMode		= AF0;
	//	Cargamos la configuracion del pin especifico
		GPIO_Config(&handlerUserLedPin0);
		GPIO_Config(&handlerUserLedPin1);
		GPIO_Config(&handlerUserLedPin2);
		GPIO_Config(&handlerUserLedPin3);
		GPIO_Config(&handlerUserLedPin4);
		GPIO_Config(&handlerUserLedPin5);
		GPIO_Config(&handlerUserLedPin6);
		GPIO_Config(&handlerUserButton);

}

/* delay para aprox 1 s*/
void delay(void){
	for(int i = 0; i < 1600000; i++){
		NOP();
	}
}


/* Funcion que actualiza los leds
 * number = 7;
 * 0b0000111 -> 7 en decimales
 *
 *
 * para b_0
 * (number >> 0) & 0x01			--------> 0b0000111 & 0x01 ---> 0x01
 *
 * para b_1
 * (number >> 1) & 0x01			--------> 0b0000011 & 0x01 ---> 0x01
 *
 * para b_2
 * (number >> 2) & 0x01			--------> 0b0000001 & 0x01 ---> 0x01
 *
 *  para b_3
 * (number >> 1) & 0x00			--------> 0b0000000 & 0x01 ---> 0x00
 *
 */

void show_Binary_Number(unsigned char number){
	unsigned char auxNumber = 0;

	// Cargamos el valor del bit_0
	auxNumber = (number >> 0) & 0x01;
	GPIO_WritePin(&handlerUserLedPin0, auxNumber);

	// Cargamos el valor del bit_1
	auxNumber = (number >> 1) & 0x01;
	GPIO_WritePin(&handlerUserLedPin1, auxNumber);

	// Cargamos el valor del bit_2
	auxNumber = (number >> 2) & 0x01;
	GPIO_WritePin(&handlerUserLedPin2, auxNumber);

	// Cargamos el valor del bit_3
	auxNumber = (number >> 3) & 0x01;
	GPIO_WritePin(&handlerUserLedPin3, auxNumber);

	// Cargamos el valor del bit_4
	auxNumber = (number >> 4) & 0x01;
	GPIO_WritePin(&handlerUserLedPin4, auxNumber);

	// Cargamos el valor del bit_5
	auxNumber = (number >> 5) & 0x01;
	GPIO_WritePin(&handlerUserLedPin5, auxNumber);

	// Cargamos el valor del bit_6
	//representa de 64 en adelante
	//sera utilizado para indicar la direccion
	//apagado:subiendo
	//encendido:disminuyendo
	//auxNumber = (number >> 6) & 0x01;
	//GPIO_WritePin(&handlerUserLedPin6, auxNumber);
}

