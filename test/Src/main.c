/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stm32f4xx.h>
#include <stdint.h>
#include "GPIOxDriver.h"
#include "BasicTimer.h"
#include "ExtiDriver.h"

uint32_t counter_2 = 0;		//Contador de prueba, funciona con el blinky

uint8_t	swFlag = 0;
uint8_t	clkFlag = 0;
uint8_t	Button	= 0;		// Boton del encoder que selecciona el modo (0) es contador, (1) es Snake
uint8_t counterNum = 0;		//Contador de los numeros
uint8_t auxSnake = 0;		//auxiliar para la serpiente
uint8_t selDisplay = 0;		//Selector de display de unidades (0) y decenas (1)


//Definicion de un elemento
GPIO_Handler_t handlerLed = {0}; 	//PA5			Led integrado
GPIO_Handler_t handlerAnodo1 = {0}; // PC8		Pin que selecciona el transistor en las unidades
GPIO_Handler_t handlerAnodo2 = {0}; // PC6		Pin que selecciona el transistor en las decenas
//handlers de los segmentos
GPIO_Handler_t handlerA = {0}; //PC6
GPIO_Handler_t handlerB = {0}; //PC6
GPIO_Handler_t handlerC = {0}; //PC6
GPIO_Handler_t handlerD = {0}; //PC6
GPIO_Handler_t handlerE = {0}; //PC6
GPIO_Handler_t handlerF = {0}; //PC6
GPIO_Handler_t handlerG = {0}; //PC6
//handlers de los pines del encoder
GPIO_Handler_t handlerEncoderClk		= {0};	// Handler del puerto CLK del encoder
GPIO_Handler_t handlerEncoderDt		= {0};  // Handler del puerto DT del encoder
GPIO_Handler_t handlerEncoderSW		= {0};	// Handler del puerto SW del encoder


BasicTimer_Handler_t	handlerTimerLed	= {0};  //Timer del led BLinky
BasicTimer_Handler_t	handlerTimerDisplay	= {0};	//TImer del display


/* = = = Handlers EXTI = = = */
EXTI_Config_t handlerExtiEncoderClk 		= {0};			// EXTI correspondiente al giro del encoder. 1->CCW ; 0->CW
EXTI_Config_t handlerExtiEncoderSW		= {0};			// EXTI correspondiente al botón del encoder


//Headers de las funciones
void init_Hardware(void);				//Inicializar el hardware
void displayNum(uint8_t num);		//Mostramos el numero en el display
void displaySnake(uint8_t numSnake);	//Mostramos el modo snake
void callback_extInt(void);
void resetAll(void);



/* INICIO DEL PROGRAMA */
int main(void){

	init_Hardware();

	while(1){
		//--------------------------------

		/*
		 * Si se pulsa el boton (SW) se levanta una bandera,
		 * la rutina de atenmcion a esta interrupcion consiste en
		 * cambiar el valor de Button y bajamos la bandera
		 */

		if(swFlag == 1){

			if(Button){
				Button = 0;
			}
			else{
				Button = 1;
			}
			swFlag = 0; //Bajamos la bandera
		}
		//--------------------------------
		/*
		 * Si se mueve la perilla del encoder, se levanta una bandera,
		 * la rutina de atencion para esta interrupcion consiste en revisar el
		 * modo en que se encuentra
		 * En este primer caso, si es contador (Button==0), leemos el valor del pin Dt
		 * y el valor de counterNum, dandole un rango entre 0 y 99
		 * si el pin esta en 1 y el counter es menor a 99, aumentamos el counter
		 * si el pin esta en 0 y el counter es mayor a 0 disminuimos el counter
		 * finalmente bajamos la bandera
		 */

		if(clkFlag == 1){//interrupcion si se mueve el clock

			//Si estamos en modo contador Button==0
			if(Button== 0){
				if(GPIO_ReadPin(&handlerEncoderDt) && counterNum < 99){
					counterNum++;
				}
				else if(!GPIO_ReadPin(&handlerEncoderDt) && counterNum > 0){
					counterNum--;
				}
				clkFlag = 0;//Bajamos la bandera
			}//Fin del modo Contador
			//----------------------------------------------------------------------------------
		}
		/*
		 * En este segundo caso, primero leemos el valor del button para entrar a modo snake
		 * aqui de acuerdo al contador empezamos en el LED A de el display de unidades,
		 * por esto no revisamos aun el exti del clk
		 * luego, si revisamos el valor del pin Dt y la bandera del clk para cambiar la posicion del snake
		 * similarmente cambiamos los valores del contador en un rango entre 0 y 11
		 * y bajamos la bandera
		 */
		//Si estamos en modo snake Button==1
		if(Button== 1){
			//Movimiento CW
			if(GPIO_ReadPin(&handlerEncoderDt) && clkFlag){
				//verificamos si auxSnake es 11 y lo hacemos 0
				if(auxSnake == 11){
					auxSnake = 0;
				}
				//de lo contrario, sumamos
				else{
					auxSnake++;
				}
				clkFlag = 0;//Bajamos la bandera
			}
			//Movimiento CCW
			else if(!GPIO_ReadPin(&handlerEncoderDt) && clkFlag){
				//verificamos si auxSnake es 0 y lo hacemos 11
				if(auxSnake == 0){
					auxSnake = 11;
				}
				//de lo contrario, restamos
				else{
					auxSnake--;
				}
				clkFlag = 0;//Bajamos la bandera
			}
			displaySnake(auxSnake);
		}//Fin del modo Snake
	}	//Fin del ciclo princial
}		//Fin del Main



//Funcion que configura el hardware, timers y extis
void init_Hardware(void){

    // Configurando el LED blinky
	handlerLed.pGPIOx									= GPIOC;
	handlerLed.GPIO_PinConfig.GPIO_PinNumber			= PIN_4;
	handlerLed.GPIO_PinConfig.GPIO_PinMode				= GPIO_MODE_OUT;
	handlerLed.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerLed.GPIO_PinConfig.GPIO_PinSpeed				= GPIO_OSPEED_FAST;
	handlerLed.GPIO_PinConfig.GPIO_PinPuPdControl		= GPIO_PUPDR_NOTHING;

    // Configurando Los selectores de los anodos comunes 	PARA UNIDADES-> PC8
	handlerAnodo1.pGPIOx								= GPIOC;
	handlerAnodo1.GPIO_PinConfig.GPIO_PinNumber			= PIN_8;
	handlerAnodo1.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerAnodo1.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerAnodo1.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_FAST;
	handlerAnodo1.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
    // Configurando Los selectores de los anodos comunes 	PARA DECENAS-> PC6
	handlerAnodo2.pGPIOx								= GPIOC;
	handlerAnodo2.GPIO_PinConfig.GPIO_PinNumber			= PIN_6;
	handlerAnodo2.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerAnodo2.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerAnodo2.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_FAST;
	handlerAnodo2.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;

	/* configuramos los pines de los 7 segmentos */
    // Configurando el segmento A-> PA9
	handlerA.pGPIOx										= GPIOA;
	handlerA.GPIO_PinConfig.GPIO_PinNumber				= PIN_9;
	handlerA.GPIO_PinConfig.GPIO_PinMode				= GPIO_MODE_OUT;
	handlerA.GPIO_PinConfig.GPIO_PinOPType				= GPIO_OTYPE_PUSHPULL;
	handlerA.GPIO_PinConfig.GPIO_PinSpeed				= GPIO_OSPEED_FAST;
	handlerA.GPIO_PinConfig.GPIO_PinPuPdControl			= GPIO_PUPDR_NOTHING;
    // Configurando el segmento B-> PC7
	handlerB.pGPIOx										= GPIOC;
	handlerB.GPIO_PinConfig.GPIO_PinNumber				= PIN_7;
	handlerB.GPIO_PinConfig.GPIO_PinMode				= GPIO_MODE_OUT;
	handlerB.GPIO_PinConfig.GPIO_PinOPType				= GPIO_OTYPE_PUSHPULL;
	handlerB.GPIO_PinConfig.GPIO_PinSpeed				= GPIO_OSPEED_FAST;
	handlerB.GPIO_PinConfig.GPIO_PinPuPdControl			= GPIO_PUPDR_NOTHING;
    // Configurando el segmento C-> PB6
	handlerC.pGPIOx										= GPIOB;
	handlerC.GPIO_PinConfig.GPIO_PinNumber				= PIN_6;
	handlerC.GPIO_PinConfig.GPIO_PinMode				= GPIO_MODE_OUT;
	handlerC.GPIO_PinConfig.GPIO_PinOPType				= GPIO_OTYPE_PUSHPULL;
	handlerC.GPIO_PinConfig.GPIO_PinSpeed				= GPIO_OSPEED_FAST;
	handlerC.GPIO_PinConfig.GPIO_PinPuPdControl			= GPIO_PUPDR_NOTHING;
    // Configurando el segmento D-> PA7
	handlerD.pGPIOx										= GPIOA;
	handlerD.GPIO_PinConfig.GPIO_PinNumber				= PIN_7;
	handlerD.GPIO_PinConfig.GPIO_PinMode				= GPIO_MODE_OUT;
	handlerD.GPIO_PinConfig.GPIO_PinOPType				= GPIO_OTYPE_PUSHPULL;
	handlerD.GPIO_PinConfig.GPIO_PinSpeed				= GPIO_OSPEED_FAST;
	handlerD.GPIO_PinConfig.GPIO_PinPuPdControl			= GPIO_PUPDR_NOTHING;
    // Configurando el segmento E-> PA6
	handlerE.pGPIOx										= GPIOA;
	handlerE.GPIO_PinConfig.GPIO_PinNumber				= PIN_6;
	handlerE.GPIO_PinConfig.GPIO_PinMode				= GPIO_MODE_OUT;
	handlerE.GPIO_PinConfig.GPIO_PinOPType				= GPIO_OTYPE_PUSHPULL;
	handlerE.GPIO_PinConfig.GPIO_PinSpeed				= GPIO_OSPEED_FAST;
	handlerE.GPIO_PinConfig.GPIO_PinPuPdControl			= GPIO_PUPDR_NOTHING;
    // Configurando el segmento F-> PC5
	handlerF.pGPIOx										= GPIOC;
	handlerF.GPIO_PinConfig.GPIO_PinNumber				= PIN_5;
	handlerF.GPIO_PinConfig.GPIO_PinMode				= GPIO_MODE_OUT;
	handlerF.GPIO_PinConfig.GPIO_PinOPType				= GPIO_OTYPE_PUSHPULL;
	handlerF.GPIO_PinConfig.GPIO_PinSpeed				= GPIO_OSPEED_FAST;
	handlerF.GPIO_PinConfig.GPIO_PinPuPdControl			= GPIO_PUPDR_NOTHING;
    // Configurando el segmento G-> PA8
	handlerG.pGPIOx										= GPIOA;
	handlerG.GPIO_PinConfig.GPIO_PinNumber				= PIN_8;
	handlerG.GPIO_PinConfig.GPIO_PinMode				= GPIO_MODE_OUT;
	handlerG.GPIO_PinConfig.GPIO_PinOPType				= GPIO_OTYPE_PUSHPULL;
	handlerG.GPIO_PinConfig.GPIO_PinSpeed				= GPIO_OSPEED_FAST;
	handlerG.GPIO_PinConfig.GPIO_PinPuPdControl			= GPIO_PUPDR_NOTHING;

	/* ================== Configuramos los pines del encoder ===========================================*/
	// Parámetros para la configuración del PB3 que respresenta a CLK
	handlerEncoderClk.pGPIOx								= GPIOB;
	handlerEncoderClk.GPIO_PinConfig.GPIO_PinNumber			= PIN_3;
	handlerEncoderClk.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_IN;
	handlerEncoderClk.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerEncoderClk.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_FAST;
	handlerEncoderClk.GPIO_PinConfig.GPIO_PinAltFunMode		= AF0;

	// Parámetros para la configuración del PB4 que representa a DT
	handlerEncoderDt.pGPIOx									= GPIOB;
	handlerEncoderDt.GPIO_PinConfig.GPIO_PinNumber			= PIN_4;
	handlerEncoderDt.GPIO_PinConfig.GPIO_PinMode				= GPIO_MODE_IN;
	handlerEncoderDt.GPIO_PinConfig.GPIO_PinPuPdControl		= GPIO_PUPDR_NOTHING;
	handlerEncoderDt.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_FAST;
	handlerEncoderDt.GPIO_PinConfig.GPIO_PinAltFunMode		= AF0;

	// Parámetros para la configuración del PB15 que representa a SW
	handlerEncoderSW.pGPIOx									= GPIOB;
	handlerEncoderSW.GPIO_PinConfig.GPIO_PinNumber			= PIN_15;
	handlerEncoderSW.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_IN;
	handlerEncoderSW.GPIO_PinConfig.GPIO_PinPuPdControl		= GPIO_PUPDR_NOTHING;
	handlerEncoderSW.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_FAST;
	handlerEncoderSW.GPIO_PinConfig.GPIO_PinAltFunMode		= AF0;

	//Cargamos la configuracion de los anodos comunes
	GPIO_Config(&handlerAnodo1);
	GPIO_Config(&handlerAnodo2);
	//Cargamos la configuracion de los 7 segmentos
	GPIO_Config(&handlerA);
	GPIO_Config(&handlerB);
	GPIO_Config(&handlerC);
	GPIO_Config(&handlerD);
	GPIO_Config(&handlerE);
	GPIO_Config(&handlerF);
	GPIO_Config(&handlerG);
	//Cargamos la configuracion de los PINES del encoder
	GPIO_Config(&handlerEncoderSW); //cargamos SW
	GPIO_Config(&handlerEncoderDt); 	//cargamos DT
	GPIO_Config(&handlerEncoderClk); 	//cargamos Clk
	GPIO_Config(&handlerLed);		//Cargamos la configuracion del blinky


	/* 	======================= Configuramos interrupciones EXTI 	======================================*/
	handlerExtiEncoderClk.edgeType 		= EXTERNAL_INTERRUPT_FALLING_EDGE;
	handlerExtiEncoderClk.pGPIOHandler	= &handlerEncoderClk; //CLK

	handlerExtiEncoderSW.edgeType 		= EXTERNAL_INTERRUPT_RISING_EDGE;
	handlerExtiEncoderSW.pGPIOHandler	= &handlerEncoderSW;

	extInt_Config(&handlerExtiEncoderClk);
	extInt_Config(&handlerExtiEncoderSW);

/* ==================================== Configurando los TIMERS =============================================*/
	//Configurando el TIM2 el cual le da la tasa de encendido al LED
	handlerTimerLed.ptrTIMx									= TIM2;
	handlerTimerLed.TIMx_Config.TIMx_mode					= BTIMER_MODE_UP;
	handlerTimerLed.TIMx_Config.TIMx_speed					= BTIMER_SPEED_1ms;
	handlerTimerLed.TIMx_Config.TIMx_period					= 250;//interrupcion cada 250ms
	handlerTimerLed.TIMx_Config.TIMx_interruptEnable		= BTIMER_INTERRUPT_ENABLE;
	//Configurando el TIM3 el cual determina la tasa de refresco del DISPLAY
	handlerTimerDisplay.ptrTIMx								= TIM3;
	handlerTimerDisplay.TIMx_Config.TIMx_mode				= BTIMER_MODE_UP;
	handlerTimerDisplay.TIMx_Config.TIMx_speed				= BTIMER_SPEED_1ms;
	handlerTimerDisplay.TIMx_Config.TIMx_period				= 10;
	handlerTimerDisplay.TIMx_Config.TIMx_interruptEnable	= BTIMER_INTERRUPT_ENABLE;
	//Cargamos la configuracion del TIM2
	BasicTimer_Config(&handlerTimerLed);
	BasicTimer_Config(&handlerTimerDisplay);
}


/* ===================== Rutinas de atencion o callbacks ===============================================*/

void BasicTimer2_Callback(void){
	counter_2++;
	GPIOxTogglePin(&handlerLed);
}

void BasicTimer3_Callback(void){
	//Si estamos en modo numero (0) se refresca el display
	if(!Button){
		if(selDisplay){
			GPIO_WritePin(&handlerAnodo1, SET);
			GPIO_WritePin(&handlerAnodo2, RESET);

			displayNum(counterNum % 10);//Mostramos el numero correspondiente

			selDisplay = 0;				//Seleccionamos display de unidades
		}
		else{
			GPIO_WritePin(&handlerAnodo1, RESET);
			GPIO_WritePin(&handlerAnodo2, SET);

			displayNum(counterNum / 10);//Mostramos el numero correspondiente

			selDisplay = 1;				//Seleccionamos display de decenas
		}
	}
}



// Callback correspondiente al boton del encoder
void callback_extInt15(void){
	swFlag =	1;	//Levantamos la bandera
}


//Callback de la rotacion del encoder (cuando hay flanco de bajada)
void callback_extInt3(void){
	clkFlag = 1;	//Levantamos la bandera
}

//Funcion que se encarga de Deplegar los numeros en el display
void displayNum(uint8_t num){
	resetAll();	//Apagamos los leds

	if (num == 1){
		GPIO_WritePin(&handlerB, SET);
		GPIO_WritePin(&handlerC, SET);
	}
	if (num == 2){
		GPIO_WritePin(&handlerA, SET);
		GPIO_WritePin(&handlerB, SET);
		GPIO_WritePin(&handlerG, SET);
		GPIO_WritePin(&handlerE, SET);
		GPIO_WritePin(&handlerD, SET);
	}
	if (num == 3){
		GPIO_WritePin(&handlerA, SET);
		GPIO_WritePin(&handlerB, SET);
		GPIO_WritePin(&handlerG, SET);
		GPIO_WritePin(&handlerC, SET);
		GPIO_WritePin(&handlerD, SET);
	}
	if (num == 4){
		GPIO_WritePin(&handlerF, SET);
		GPIO_WritePin(&handlerG, SET);
		GPIO_WritePin(&handlerB, SET);
		GPIO_WritePin(&handlerC, SET);
	}
	if (num == 5){
		GPIO_WritePin(&handlerA, SET);
		GPIO_WritePin(&handlerF, SET);
		GPIO_WritePin(&handlerG, SET);
		GPIO_WritePin(&handlerC, SET);
		GPIO_WritePin(&handlerD, SET);
	}
	if (num == 6){
		GPIO_WritePin(&handlerA, SET);
		GPIO_WritePin(&handlerF, SET);
		GPIO_WritePin(&handlerG, SET);
		GPIO_WritePin(&handlerC, SET);
		GPIO_WritePin(&handlerE, SET);
		GPIO_WritePin(&handlerD, SET);
	}
	if (num == 7){
		GPIO_WritePin(&handlerA, SET);
		GPIO_WritePin(&handlerB, SET);
		GPIO_WritePin(&handlerC, SET);
	}
	if (num == 8){
		GPIO_WritePin(&handlerA, SET);
		GPIO_WritePin(&handlerB, SET);
		GPIO_WritePin(&handlerC, SET);
		GPIO_WritePin(&handlerD, SET);
		GPIO_WritePin(&handlerE, SET);
		GPIO_WritePin(&handlerF, SET);
		GPIO_WritePin(&handlerG, SET);
	}
	if (num == 9){
		GPIO_WritePin(&handlerA, SET);
		GPIO_WritePin(&handlerB, SET);
		GPIO_WritePin(&handlerC, SET);
		GPIO_WritePin(&handlerD, SET);
		GPIO_WritePin(&handlerF, SET);
		GPIO_WritePin(&handlerG, SET);
	}
	if (num == 0){
		GPIO_WritePin(&handlerA, SET);
		GPIO_WritePin(&handlerB, SET);
		GPIO_WritePin(&handlerC, SET);
		GPIO_WritePin(&handlerD, SET);
		GPIO_WritePin(&handlerE, SET);
		GPIO_WritePin(&handlerF, SET);
	}
}


//Funcion que se encarga de encender/apagar los pines de acuerdo a la posicion del Snake
void displaySnake(uint8_t numSnake){
	resetAll();	//Apagamos los leds


	if(numSnake == 0){
		GPIO_WritePin(&handlerAnodo2, RESET);
		GPIO_WritePin(&handlerAnodo1, SET);
		GPIO_WritePin(&handlerA, SET);

	}
	if(numSnake == 1){
		GPIO_WritePin(&handlerAnodo2, RESET);
		GPIO_WritePin(&handlerAnodo1, SET);
		GPIO_WritePin(&handlerB, SET);
	}
	if(numSnake == 2){
		GPIO_WritePin(&handlerAnodo2, RESET);
		GPIO_WritePin(&handlerAnodo1, SET);
		GPIO_WritePin(&handlerC, SET);
	}
	if(numSnake == 3){
		GPIO_WritePin(&handlerAnodo2, RESET);
		GPIO_WritePin(&handlerAnodo1, SET);
		GPIO_WritePin(&handlerD, SET);
	}
	if(numSnake == 4){
		GPIO_WritePin(&handlerAnodo1, RESET);
		GPIO_WritePin(&handlerAnodo2, SET);
		GPIO_WritePin(&handlerC, SET);
	}
	if(numSnake == 5){
		GPIO_WritePin(&handlerAnodo1, RESET);
		GPIO_WritePin(&handlerAnodo2, SET);
		GPIO_WritePin(&handlerB, SET);
	}
	if(numSnake == 6){
		GPIO_WritePin(&handlerAnodo2, RESET);
		GPIO_WritePin(&handlerAnodo1, SET);
		GPIO_WritePin(&handlerF, SET);
	}
	if(numSnake == 7){
		GPIO_WritePin(&handlerAnodo2, RESET);
		GPIO_WritePin(&handlerAnodo1, SET);
		GPIO_WritePin(&handlerE, SET);
	}
	if(numSnake == 8){
		GPIO_WritePin(&handlerAnodo1, RESET);
		GPIO_WritePin(&handlerAnodo2, SET);
		GPIO_WritePin(&handlerD, SET);

	}
	if(numSnake == 9){
		GPIO_WritePin(&handlerAnodo1, RESET);
		GPIO_WritePin(&handlerAnodo2, SET);
		GPIO_WritePin(&handlerE, SET);
	}
	if(numSnake == 10){
		GPIO_WritePin(&handlerAnodo1, RESET);
		GPIO_WritePin(&handlerAnodo2, SET);
		GPIO_WritePin(&handlerF, SET);
	}
	if(numSnake == 11){
		GPIO_WritePin(&handlerAnodo1, RESET);
		GPIO_WritePin(&handlerAnodo2, SET);
		GPIO_WritePin(&handlerA, SET);
	}
}

//Funcion que apaga todos los pines del 7 segmentos
void resetAll(void){
	GPIO_WritePin(&handlerA, RESET);
	GPIO_WritePin(&handlerB, RESET);
	GPIO_WritePin(&handlerC, RESET);
	GPIO_WritePin(&handlerD, RESET);
	GPIO_WritePin(&handlerE, RESET);
	GPIO_WritePin(&handlerF, RESET);
	GPIO_WritePin(&handlerG, RESET);

}

