/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>

#include <stm32f4xx.h>

#include "GPIOxDriver.h"
#include "BasicTimer.h"
#include "ExtiDriver.h"
#include "USARTxDriver.h"

#include <string.h>
#include <ctype.h>

#define ROWS 3
#define COLS 2


//handlers de los segmentos
GPIO_Handler_t GPIO_StructHandlers[ROWS][COLS]= {0};
GPIO_Handler_t handlerBlinkyPin = {0};
uint32_t counter = 0;		//Contador de prueba, funciona con el blinky


GPIO_Handler_t handlerPinTX = {0};
GPIO_Handler_t handlerPinRX = {0};
USART_Handler_t usart2Comm = {0};

int state[ROWS][COLS] = {
		{0,0},
		{0,0},
		{0,0}
};

    // Pines
int ledPins[ROWS][COLS] = {
		{PIN_10,PIN_6},
		{PIN_11,PIN_7},
		{PIN_12,PIN_8}
};

uint8_t flagBraille = RESET;
uint8_t auxBraille = 0;







BasicTimer_Handler_t	handlerTimerLed	= {0};  //Timer del led BLinky
BasicTimer_Handler_t	handlerBrailleTimer				= {0};




//Headers de las funciones
void init_Hardware(void);				//Inicializar el hardware
void clearLEDMatrix(void);
void updateLEDMatrix(int state[][COLS]);
void alfabetoBraille(char letra);




/* INICIO DEL PROGRAMA */
int main(void){

	init_Hardware();
	char str[] = "Hola mundo";
//	char strMod[] = "#hola #mundo &12";
	// usar simbolos de codigo ascii o ascii etendido
	int len = strlen(str);
//	char dummy = 'm';
//	alfabetoBraille(dummy);

//	char caracteres[len];
//
//	for(int i =0; i < len; i++){
//		caracteres[i] = str[i];
//	}
//
////	//imprimir los caracteres almacenados
////	for (int i = 0; i < len;i++){
////		printf("%c", caracteres[i]);
//	}
//	int state[ROWS][COLS] = {
//			{0,0},
//			{1,1},
//			{0,0}
//	};

//		updateLEDMatrix(state);


	while(1){
		if (flagBraille== SET){
			alfabetoBraille(str[auxBraille]);
			flagBraille = RESET;
			auxBraille++;
//			if (auxBraille == len){
//				stopTimer(&handlerTimerLed);
//			}
		}




	}	//Fin del ciclo princial
}		//Fin del Main



//Funcion que configura el hardware, timers y extis
void init_Hardware(void){


	handlerBlinkyPin.pGPIOx											= GPIOA;
	handlerBlinkyPin.GPIO_PinConfig.GPIO_PinNumber					= PIN_5;
	handlerBlinkyPin.GPIO_PinConfig.GPIO_PinMode					= GPIO_MODE_OUT;
	handlerBlinkyPin.GPIO_PinConfig.GPIO_PinOPType					= GPIO_OTYPE_PUSHPULL;
	handlerBlinkyPin.GPIO_PinConfig.GPIO_PinSpeed					= GPIO_OSPEED_FAST;
	handlerBlinkyPin.GPIO_PinConfig.GPIO_PinPuPdControl				= GPIO_PUPDR_NOTHING;
	GPIO_Config(&handlerBlinkyPin);


	//Configurar los pines de GPIO como salida

//	for (int row = 0; row < ROWS ;row++){
//		GPIO_StructHandlers[row][0].pGPIOx = GPIOC;
//		GPIO_StructHandlers[row][1].pGPIOx = GPIOA;};

	for (int row = 0; row < ROWS ;row++){
		for (int col = 0; col < COLS ;col++){
			GPIO_StructHandlers[row][col].pGPIOx 								= (col == 0) ? GPIOC : GPIOA;
	        GPIO_StructHandlers[row][col].GPIO_PinConfig.GPIO_PinNumber			= ledPins[row][col];
	        GPIO_StructHandlers[row][col].GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	        GPIO_StructHandlers[row][col].GPIO_PinConfig.GPIO_PinSpeed       	= GPIO_OSPEED_FAST;
	        GPIO_StructHandlers[row][col].GPIO_PinConfig.GPIO_PinPuPdControl 	= GPIO_PUPDR_NOTHING;
	        GPIO_StructHandlers[row][col].GPIO_PinConfig.GPIO_PinOPType      	= GPIO_OTYPE_PUSHPULL;
	        GPIO_StructHandlers[row][col].GPIO_PinConfig.GPIO_PinAltFunMode  	= AF0;
		}
	};

	//Cargamos la configuracion de los LEDS
	for (int row = 0; row < ROWS ;row++){
		for (int col = 0; col < COLS ;col++){
			GPIO_Config(&GPIO_StructHandlers[row][col]);
		}
	};


/* ==================================== Configurando los TIMERS =============================================*/
	//Configurando el TIM2 el cual le da la tasa de encendido al LED
	handlerTimerLed.ptrTIMx									= TIM2;
	handlerTimerLed.TIMx_Config.TIMx_mode					= BTIMER_MODE_UP;
	handlerTimerLed.TIMx_Config.TIMx_speed					= BTIMER_SPEED_1ms;
	handlerTimerLed.TIMx_Config.TIMx_period					= 250;//interrupcion cada 250ms
	handlerTimerLed.TIMx_Config.TIMx_interruptEnable		= BTIMER_INTERRUPT_ENABLE;
	BasicTimer_Config(&handlerTimerLed);



	handlerBrailleTimer.ptrTIMx									= TIM3;
	handlerBrailleTimer.TIMx_Config.TIMx_mode					= BTIMER_MODE_UP;
	handlerBrailleTimer.TIMx_Config.TIMx_speed					= BTIMER_SPEED_1ms;
	handlerBrailleTimer.TIMx_Config.TIMx_period					= 1000;//interrupcion cada 250ms
	handlerBrailleTimer.TIMx_Config.TIMx_interruptEnable		= BTIMER_INTERRUPT_ENABLE;
	BasicTimer_Config(&handlerBrailleTimer);
}
/* ===================== Rutinas de atencion o callbacks ===============================================*/
void BasicTimer3_Callback(void){
	counter++;
	flagBraille = SET;
}

void BasicTimer2_Callback(void){
GPIOxTogglePin(&handlerBlinkyPin);
}

void clearLEDMatrix(void){
	int state[ROWS][COLS] = {
			{0,0},
			{0,0},
			{0,0}
	};
	updateLEDMatrix(state);
}

void updateLEDMatrix(int state[][COLS]){
	for(int i = 0; i < ROWS;i++){
		for(int j = 0; j<COLS;j++){
			GPIO_WritePin(&GPIO_StructHandlers[i][j], state[i][j]);
		}
	}
}

void alfabetoBraille(char letra){

	if (isupper(letra)){
		int state[ROWS][COLS] = {
				{0,1},
				{0,0},
				{0,1}
		};
		updateLEDMatrix(state);
	}

	if(isdigit(letra)){
		int state[ROWS][COLS] = {
				{0,1},
				{0,1},
				{1,1}
		};
		updateLEDMatrix(state);
	}

	switch (tolower(letra)) {
		case 'a':
		case '1':
		{
			int new_state[ROWS][COLS] = {
					{1,0},
					{0,0},
					{0,0}
			};
			memcpy(state,new_state,sizeof(state));
			break;
		}
		case 'b':
		{
			int new_state[ROWS][COLS] = {
				{1,0},
				{1,0},
				{0,0}
			};
			memcpy(state,new_state,sizeof(state));
			break;
		}
		case 'h':
		{
			int new_state[ROWS][COLS] = {
					{1,0},
					{1,1},
					{0,0}
			};
			memcpy(state,new_state,sizeof(state));
			break;
		}
		case 'o':
		{
			int new_state[ROWS][COLS] = {
					{1,0},
					{0,0},
					{0,0}
			};
			memcpy(state,new_state,sizeof(state));
			break;
		}
		case 'l':
		{
			int new_state[ROWS][COLS] = {
					{1,0},
					{1,0},
					{1,0}
			};
			memcpy(state,new_state,sizeof(state));
			break;
		}
		case 'm':
		{
			int new_state[ROWS][COLS] = {
					{1,1},
					{0,0},
					{1,0}
			};
			memcpy(state,new_state,sizeof(state));
			break;
		}
		case 'u':
		{
			int new_state[ROWS][COLS] = {
					{1,0},
					{0,0},
					{1,1}
			};
			memcpy(state,new_state,sizeof(state));
			break;
		}
		case 'n':
		{
			int new_state[ROWS][COLS] = {
					{1,1},
					{0,1},
					{1,0}
			};
			memcpy(state,new_state,sizeof(state));
			break;
		}
		case 'd':
		{
			int new_state[ROWS][COLS] = {
					{1,1},
					{0,1},
					{0,0}
			};
			memcpy(state,new_state,sizeof(state));
			break;
		}
		case ' ':
		{
			int new_state[ROWS][COLS] = {
					{0,0},
					{0,0},
					{0,0}
			};
			memcpy(state,new_state,sizeof(state));
			break;
		}
	default:
		break;
	}
	updateLEDMatrix(state);
}

