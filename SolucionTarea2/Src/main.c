/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f411xx_hal.h"
#include "GPIOxDriver.h"

//	Definimos los bits que corresponderán a los leds

uint8_t bit0 = 0;
uint8_t bit1 = 0;
uint8_t bit2 = 0;
uint8_t bit3 = 0;
uint8_t bit4 = 0;
uint8_t bit5 = 0;
uint8_t bit6 = 0;
uint8_t USER_BUTTON = 0;
uint16_t test_var	= 0;
uint16_t test_var2	= 0;
int counter_i = 0;

// 	Definimos el handler para el PIN que deseamos configurar

GPIO_Handler_t handlerUserLedPin0 = {0};
GPIO_Handler_t handlerUserLedPin1 = {0};
GPIO_Handler_t handlerUserLedPin2 = {0};
GPIO_Handler_t handlerUserLedPin3 = {0};
GPIO_Handler_t handlerUserLedPin4 = {0};
GPIO_Handler_t handlerUserLedPin5 = {0};
GPIO_Handler_t handlerUserLedPin6 = {0};
GPIO_Handler_t handlerUserButton = {0};

void EncenderLed(uint8_t counter_i);

int main(void)
{
	/*
	 * PUNTO 1
	 * a) El error presente en el código es que al leer el pin, solo nos interesa
	 * el valor del bit en la posición 0, pero tenemos más valores que no son necesarios
	 *
	 * b) se puede solucionar aplicando una máscara que nos elimine toda la información
	 * innecesaria, i.e. los bits diferentes al bit 0
	 *
	 * c) esta corrección la realizamos en el archivo GPIOxDriver.c
	 * agregando la línea que nos aplica la máscara:
	 * pinValue &= (0b1);
	 * De esta manera hacemos 0 todos los bits, excepto el bit0 que contiene
	 * la información que nos importa en este caso
	 *
	 *
	 * A continuación un código con un ejemplo de la solución que se puede
	 * comprobar en el debugger
	 */




	GPIO_Handler_t handlerUserLedPin = {0};
//	deseamos trabajar con el puerto GPIOA
	handlerUserLedPin.pGPIOx = GPIOA;
	handlerUserLedPin.GPIO_PinConfig.GPIO_PinNumber			= PIN_5;	//este es el LED integrado del MCU
	handlerUserLedPin.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerUserLedPin.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerUserLedPin.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerUserLedPin.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;
	handlerUserLedPin.GPIO_PinConfig.GPIO_PinAltFunMode		= AF0;

//	Cargamos la configuracion del pin especifico
	GPIO_Config(&handlerUserLedPin);
//	Hacemos que el PIN_A5 quede encendido
	GPIO_WritePin(&handlerUserLedPin, SET);
	test_var = GPIO_ReadPin(&handlerUserLedPin);

/*
 * PUNTO 2
 *
 * La función GPIOxTogglePin se crea dentro del archivo GPIOxDriver.c
 * donde leemos el valor (0 ó 1) que toma el PIN y lo asignamos a la variable "estado"
 * mediante una operación bitwise XOR, tenemos dos entradas: la primera es
 * de la lectura del PIN, y la segunda, la forzamos a ser 1, para que así, de salida
 * obtengamos el valor opuesto a la entrada leída
 * con esto, usando la función Toggle asignamos el valor contrario
 *
 */

	GPIOxTogglePin(&handlerUserLedPin);
	test_var = GPIO_ReadPin(&handlerUserLedPin);
	GPIOxTogglePin(&handlerUserLedPin);
	test_var2 = GPIO_ReadPin(&handlerUserLedPin);

/*
 * PUNTO 3
 *
 * En este ejercicio, asignamos el handler de 7 pines, y también 7 variables correspondientes
 * a los pines que tomanán el valor a medida que el contador aumente cada segundo.
 *
 * Para esto, debemos crear una función encargada de encender el led. En esta función, tomando
 * el valor que tiene el contador, le aplicamos una máscara a este número y eliminamos
 * los valores que no nos interesen, según en qué bit nos encontremos posicionados,
 * es decir, si estamos en el pin que representa al led 2, eliminamos
 * todos los bits expecto el bit 2
 *
 * Luego revisamos si el valor que tiene el PIN, es diferente de 0
 * y enciende el respectivo LED
 *
 */




//	GPIOA 7
	handlerUserLedPin0.pGPIOx = GPIOA;
	handlerUserLedPin0.GPIO_PinConfig.GPIO_PinNumber			= PIN_7;
	handlerUserLedPin0.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerUserLedPin0.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerUserLedPin0.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerUserLedPin0.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;
	handlerUserLedPin0.GPIO_PinConfig.GPIO_PinAltFunMode		= AF0;

//	GPIOA	8
	handlerUserLedPin1.pGPIOx = GPIOC;
	handlerUserLedPin1.GPIO_PinConfig.GPIO_PinNumber			= PIN_8;
	handlerUserLedPin1.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerUserLedPin1.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerUserLedPin1.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerUserLedPin1.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;
	handlerUserLedPin1.GPIO_PinConfig.GPIO_PinAltFunMode		= AF0;

//	GPIOC 7
	handlerUserLedPin2.pGPIOx = GPIOC;
	handlerUserLedPin2.GPIO_PinConfig.GPIO_PinNumber			= PIN_7;
	handlerUserLedPin2.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerUserLedPin2.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerUserLedPin2.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerUserLedPin2.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;
	handlerUserLedPin2.GPIO_PinConfig.GPIO_PinAltFunMode		= AF0;

//	GPIOA 6
	handlerUserLedPin3.pGPIOx = GPIOA;
	handlerUserLedPin3.GPIO_PinConfig.GPIO_PinNumber			= PIN_6;
	handlerUserLedPin3.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerUserLedPin3.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerUserLedPin3.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerUserLedPin3.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;
	handlerUserLedPin3.GPIO_PinConfig.GPIO_PinAltFunMode		= AF0;

//	GPIOB 8
	handlerUserLedPin4.pGPIOx = GPIOB;
	handlerUserLedPin4.GPIO_PinConfig.GPIO_PinNumber			= PIN_8;
	handlerUserLedPin4.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerUserLedPin4.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerUserLedPin4.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerUserLedPin4.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;
	handlerUserLedPin4.GPIO_PinConfig.GPIO_PinAltFunMode		= AF0;

//	GPIOC 6
	handlerUserLedPin5.pGPIOx = GPIOC;
	handlerUserLedPin5.GPIO_PinConfig.GPIO_PinNumber			= PIN_6;
	handlerUserLedPin5.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerUserLedPin5.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerUserLedPin5.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerUserLedPin5.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;
	handlerUserLedPin5.GPIO_PinConfig.GPIO_PinAltFunMode		= AF0;

//	GPIOC 9
	handlerUserLedPin6.pGPIOx = GPIOC;
	handlerUserLedPin6.GPIO_PinConfig.GPIO_PinNumber			= PIN_9;
	handlerUserLedPin6.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerUserLedPin6.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerUserLedPin6.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerUserLedPin6.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;
	handlerUserLedPin6.GPIO_PinConfig.GPIO_PinAltFunMode		= AF0;
//	BOTON
	handlerUserButton.pGPIOx = GPIOC;
	handlerUserButton.GPIO_PinConfig.GPIO_PinNumber			= PIN_13;
	handlerUserButton.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_IN;
	handlerUserButton.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerUserButton.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerUserButton.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;
	handlerUserButton.GPIO_PinConfig.GPIO_PinAltFunMode		= AF0;


//	Cargamos la configuracion del pin especifico
	GPIO_Config(&handlerUserLedPin0);
	GPIO_Config(&handlerUserLedPin1);
	GPIO_Config(&handlerUserLedPin2);
	GPIO_Config(&handlerUserLedPin3);
	GPIO_Config(&handlerUserLedPin4);
	GPIO_Config(&handlerUserLedPin5);
	GPIO_Config(&handlerUserLedPin6);
	GPIO_Config(&handlerUserButton);

//	Probamos el encendido de los LEDS
	GPIO_WritePin(&handlerUserLedPin0, SET);
	GPIO_WritePin(&handlerUserLedPin1, SET);
	GPIO_WritePin(&handlerUserLedPin2, SET);
	GPIO_WritePin(&handlerUserLedPin3, SET);
	GPIO_WritePin(&handlerUserLedPin4, SET);
	GPIO_WritePin(&handlerUserLedPin5, SET);
	GPIO_WritePin(&handlerUserLedPin6, SET);



//	test_var = GPIOxTogglePin(&test_var);
//	test_var2 = GPIOxTogglePin(&test_var2);


	//Este es el ciclo principal, donde se ejecuta todo el programa
	while(1){

//			Guardamos el valor del estado del boton
			USER_BUTTON = GPIO_ReadPin(&handlerUserButton);

			EncenderLed(counter_i);

			if(USER_BUTTON == 1){
				counter_i += 1;		//el contador aumenta con el botón sin pulsar
			}else{
				counter_i -= 1;		//el contador disminuye cuando se pulsa el botón
			}

			if(counter_i  > 60){	//si llegamos a mpas de 60 empezamos desde 1
				counter_i = 1;
			}

			if(counter_i  < 1){		//si llegamos a menos de 1 contamos desde 60
				counter_i = 60;
			}

			for (int i=0;(i < 1250000);i++){	//asignamos el valor hasta el que contamos
				NOP();
			}
	}
}
//fin de la funcion Main




/*
 * A continuación establecemos el método para encender los leds, donde teniendo en cuenta el valor
 * binario que toma el contador
 *
 * Mediante la funcion EncenderLed
 */
void EncenderLed(uint8_t counter_i){

//	Aplicando las máscaras
	bit0 = counter_i & 0b1;
	bit1 = counter_i & 0b1 << 1;
	bit2 = counter_i & 0b1 << 2;
	bit3 = counter_i & 0b1 << 3;
	bit4 = counter_i & 0b1 << 4;
	bit5 = counter_i & 0b1 << 5;
	bit6 = counter_i & 0b1 << 6;
//	Revisando si el bit correspondiente a cada LED es diferente de 0 para encenderlo
	if(bit0 != 0){
		GPIO_WritePin(&handlerUserLedPin0, SET);
	}
	else{
		GPIO_WritePin(&handlerUserLedPin0, RESET);
	}
	if(bit1 != 0){
		GPIO_WritePin(&handlerUserLedPin1, SET);
	}
	else{
		GPIO_WritePin(&handlerUserLedPin1, RESET);
	}
	if(bit2 != 0){
		GPIO_WritePin(&handlerUserLedPin2, SET);
	}
	else{
		GPIO_WritePin(&handlerUserLedPin2, RESET);
	}
	if(bit3 != 0){
		GPIO_WritePin(&handlerUserLedPin3, SET);
	}
	else{
		GPIO_WritePin(&handlerUserLedPin3, RESET);
	}
	if(bit4 != 0){
		GPIO_WritePin(&handlerUserLedPin4, SET);
	}
	else{
		GPIO_WritePin(&handlerUserLedPin4, RESET);
	}
	if(bit5 != 0){
		GPIO_WritePin(&handlerUserLedPin5, SET);
	}
	else{
		GPIO_WritePin(&handlerUserLedPin5, RESET);
	}
	if(bit6 != 0){
		GPIO_WritePin(&handlerUserLedPin6, SET);
	}
	else{
		GPIO_WritePin(&handlerUserLedPin6, RESET);
	}
}
