/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f411xx_hal.h"
#include "GPIOxDriver.h"


/*
 * Definición de los elementos del programa
 */
GPIO_Handler_t handler_Led2			= {0};	//PA5
GPIO_Handler_t handler_UserButton	= {0};	//PC13

BasicTimer_Handler_t handlerBlinkyTimer = {0};//TIM2

uint32_t counterExti13= 0;

/*
 * Prototipos de las funciones del main
 */
void init_Hardware(void);
void callback_exti13(void);




int main(void){

	//Cargamos la cionfiguracuib de tidis kis ekenebtis
	init_Hardware();

	while(1){

	}
	return 0;
}

void init_Hardware(void){
	handler_Led2.pGPIOx = GPIOA;
	handler_Led2.GPIO_PinConfig.GPIO_PinNumber		= PIN_5;
	handler_Led2.GPIO_PinConfig.GPIO_PinMode		= GPIO_MODE_OUT;
	handler_Led2.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handler_Led2.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;
	handler_Led2.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;


	GPIO_Config(&handler_Led2);
	GPIO_WritePin(&handler_Led2, SET);


	/*
	 * Configuramos el TIM2 para hacer un bliny de 250 ms
	 */
	handlerBlinkyTimer.ptrTimx = TIM2;
	handlerBlinkyTimer.TIMx_Config.TIMx_mode	=	BTIMER_MODE_UP;
	handlerBlinkyTimer.TIMx_Config.TIMx_speed	=	BTIMER_SPEED_1ms;
	handlerBlinkyTimer.TIMx_Config.TIMx_period	=	250;
	handlerBlinkyTimer.TIMx_Config.TIMx_interruptEnable	=	BTIMER_INTERRUPT_ENABLE;

	BasicTimer_Config(&handlerBlinkyTimer);

	//configurando el pin C13(BOTON) como entrada
	handler_UserButton.pGPIOx = GPIOC;
	handler_UserButton.GPIO_PinConfig.GPIO_PinNumber		= PIN_13;
	handler_UserButton.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_IN;
	handler_UserButton.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;

	/* 1. cargando la congururacion en los registors del mcu */
	GPIO_Config(&handler_UserButton);
	/* 2.a Activar la señal de reloj para el SYSCFG */
	RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
	/* 2.b configurar el multiplexor 13 asignando el puerto GPIOC */
	SYSCFG->ETICR[3] &= ~ (0xF <<SYSCFG_EXTICR4_EXTI13_Pos);	//limpiamos la pos del mux13
	SYSCFG->ETICR[3] |= (0xF <<SYSCFG_EXTICR4_EXTI13_PC);	//Asignamos el puerto C

	/* 3. CONFIGURAMOS EL EXTI */
	EXTI->FTSR = 0; //Desactivamos TODAS las posibles detecciones de falling edge
	EXTI->RTSR = 0;	//Llevamos a un valor conocido el registro
	EXTI->RTSR |= EXTI_RTSR_TR13;//Activando la detecckon de rising edge en PIN13
	EXTI->IMR = 0;
	EXTI->IMR |= EXTI_IMR_IM13;	//Activamos la interrupcion EXTI_13

	/* 4a. Desactivar las interrupciones globales */
	__disable_irq();

	/* 4b. Desactivar las interrupciones globales */
	NVIC_EnableIRQ(EXTI15_10_IRQn);

	/* 4c. crear ISR */
	/* 4d. callback */

	/* 5. callback */
	enable_irq();



}

/* 5.
 * verificar la interrupcion
 * bajar la bandera
 * Llamar Callback
 */
void EXTI15_10_IRQHandler(void){
	/* Verificamos la interrupcion */
	if((EXTI->PR & EXTI_PR_PR13) != 0){
		//Efectivamente es la interrupcion 13 LA QUE SE ACTIVÓ
		EXTI->PR |= EXTI_PR_PR13;
		callback_exti13();

	}
}


void callback_exti13(){
	counterExti13++ ;
}


void BasicTImer2_Callback(void){
	GPIOxTogglePin(&handler_Led2)
}


